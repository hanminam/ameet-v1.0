<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMEET - AI Collective Intelligence Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9;
            color: #1e293b;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .screen { display: none; }
        .screen.active { display: block; }
        .screen-card {
            background-color: white;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 48rem; /* 768px */
            margin: 2rem;
            overflow: hidden;
        }
        .screen-header {
            background-color: #f8fafc;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 700;
            color: #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .screen-body { padding: 2rem; }
        .text-primary { color: #2563eb; }
        .btn { border-radius: 0.75rem; font-weight: 700; padding: 0.75rem 1.5rem; transition: all 0.2s ease; cursor: pointer; }
        .btn-primary { background-color: #2563eb; color: white; }
        .btn-primary:hover { background-color: #1d4ed8; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3); }
        .btn-primary:disabled { background-color: #93c5fd; cursor: not-allowed; }

        /* 토론 흐름도 화살표 스타일 */
        .flow-line {
            position: absolute;
            height: 3px; /* 기본 두께를 약간 두껍게 조정 */
            transform-origin: 0 0;
            transition: all 0.2s ease-in-out; /* 부드러운 효과를 위한 트랜지션 */
            z-index: 10; /* 기본 화살표 z-index 설정 */
        }
        .flow-line::after {
            content: '';
            position: absolute;
            right: -1px;
            top: -3.5px; /* 두께에 맞춰 위치 조정 */
            border-style: solid;
            border-width: 0 3px 3px 0;
            display: inline-block;
            padding: 3.5px;
            transform: rotate(-45deg);
        }

        /* 마우스 오버 시 비활성화된 화살표 스타일 */
        .flow-line.dimmed {
            opacity: 0.15;
            z-index: 5; /* 흐려진 화살표는 뒤로 보냄 */
        }

        /* 마우스 오버 시 강조되는 화살표 스타일 */
        .flow-line.highlighted {
            height: 5px; /* 두께를 더 두껍게 */
            opacity: 1;
            z-index: 20; /* 강조된 화살표를 가장 위로 보냄 */
        }
        .flow-line.highlighted::after {
            top: -4.5px; /* 강조된 두께에 맞춰 위치 재조정 */
        }

        /* 에이전트별 화살표 색상 정의 (7개) */
        .flow-line-color-0 { background-color: #ef4444; } /* red-500 */
        .flow-line-color-0::after { border-color: #ef4444; }
        .flow-line-color-1 { background-color: #3b82f6; } /* blue-500 */
        .flow-line-color-1::after { border-color: #3b82f6; }
        .flow-line-color-2 { background-color: #22c55e; } /* green-500 */
        .flow-line-color-2::after { border-color: #22c55e; }
        .flow-line-color-3 { background-color: #eab308; } /* yellow-500 */
        .flow-line-color-3::after { border-color: #eab308; }
        .flow-line-color-4 { background-color: #8b5cf6; } /* violet-500 */
        .flow-line-color-4::after { border-color: #8b5cf6; }
        .flow-line-color-5 { background-color: #ec4899; } /* pink-500 */
        .flow-line-color-5::after { border-color: #ec4899; }
        .flow-line-color-6 { background-color: #f97316; } /* orange-500 */
        .flow-line-color-6::after { border-color: #f97316; }

        /* 긴 텍스트 (주로 URL) 줄바꿈 처리 */
        .break-word-container {
            word-wrap: break-word; /* 오래된 브라우저 호환 */
            word-break: break-word; /* 최신 브라우저 (Chrome, Firefox 등) */
        }

        /* 토론 흐름도 화살표 스타일 개선 */
        .flow-line {
            position: absolute;
            background-color: #cbd5e1; /* slate-300 */
            height: 2px;
            transform-origin: 0 0;
            transition: all 0.3s ease-in-out;
            z-index: 10;
            opacity: 0.15; /* 기본 상태를 흐리게 (요청사항 3) */
        }
        .flow-line::after {
            content: '';
            position: absolute;
            right: -1px;
            top: -3.5px;
            border-style: solid;
            border-width: 0 2px 2px 0;
            display: inline-block;
            padding: 3px;
            transform: rotate(-45deg);
            border-color: #cbd5e1; /* slate-300 */
        }
        /* 마우스 오버 시 하이라이트 스타일 */
        .flow-line.highlighted {
            height: 3px;
            opacity: 1;
            z-index: 20;
        }
        .flow-line.highlighted::after {
            right: -1.5px;
            top: -4.5px;
            padding: 4px;
        }
        /* 다른 에이전트 오버 시 숨김 처리 */
        .flow-line.hidden {
            opacity: 0;
        }
        /* 상호작용 유형별 색상 */
        .flow-line-agreement { background-color: #22c55e; } /* green-500 */
        .flow-line-agreement::after { border-color: #22c55e; }
        .flow-line-disagreement { background-color: #ef4444; } /* red-500 */
        .flow-line-disagreement::after { border-color: #ef4444; }

        /* 단순화된 토론 흐름도 리스트 스타일 */
        .flow-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9; /* slate-100 */
        }
        .flow-agent-box {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-basis: 40%; /* 양쪽 에이전트 박스가 공간을 차지하도록 */
        }
        .flow-agent-box.from {
            justify-content: flex-start;
        }
        .flow-agent-box.to {
            justify-content: flex-end;
            text-align: right;
        }
        .flow-arrow {
            flex-grow: 1;
            text-align: center;
        }
        .flow-arrow svg {
            width: 100%;
            height: 16px;
        }
        .arrow-agreement path {
            stroke: #22c55e; /* green-500 */
        }
        .arrow-disagreement path {
            stroke: #ef4444; /* red-500 */
        }
    </style>
</head>
<body class="antialiased">

    <div id="screen-login" class="screen active screen-card">
        <div class="screen-body text-center">
            <h2 class="text-3xl font-bold text-slate-800">AMEET</h2>
            <p class="text-slate-600 mt-2 mb-8">로그인 후 AI 집단지성 토론을 시작하세요.</p>
            <div id="login-form" class="max-w-sm mx-auto space-y-4">
                <input type="email" id="email-input" placeholder="이메일 주소 (user@example.com)" class="w-full p-3 border-slate-300 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" value="user@example.com">
                <input type="password" id="password-input" placeholder="비밀번호 (userpassword)" class="w-full p-3 border-slate-300 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" value="userpassword">
                <button id="login-button" class="btn btn-primary w-full">로그인</button>
                <p id="login-error" class="text-sm text-red-500 h-4"></p>
            </div>
        </div>
    </div>

    <div id="screen-topic" class="screen screen-card">
        <div class="screen-header">
            <span class="font-bold">주제 입력</span>
            <div class="flex items-center gap-4">
                <span id="user-email-display" class="text-sm font-medium text-slate-600"></span>
                <button id="logout-button" class="text-sm font-bold text-red-500 hover:underline">로그아웃</button>
            </div>
        </div>
        <div class="screen-body text-center">
            <h2 class="text-3xl font-bold text-slate-800">무엇에 대해 토론할까요?</h2>
            <p class="text-slate-600 mt-2 mb-8">AI 집단지성이 깊이 있는 통찰을 제공합니다.</p>
            <div class="bg-slate-50 p-6 rounded-xl border">
                <textarea id="topic-input" class="w-full h-28 p-3 border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-base" placeholder="예: 테슬라의 6개월 뒤 주가 전망"></textarea>
                <div class="flex flex-col sm:flex-row justify-between items-center mt-4 gap-4">
                    <label class="flex items-center gap-2 text-sm text-slate-600 hover:text-primary cursor-pointer">
                        <input type="file" id="file-input" class="hidden">
                        📎 <span id="file-name-display">참고 파일 첨부 (TXT, PDF)</span>
                    </label>
                    <button id="start-analysis-button" class="btn btn-primary w-full sm:w-auto">분석 시작</button>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-analysis" class="screen screen-card">
        <div class="screen-header"><span>토론 준비: AI 분석 과정</span></div>
        <div class="screen-body">
            <div class="text-center mb-8">
                <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto"></div>
                <h2 id="analysis-status-text" class="text-2xl font-bold text-slate-800 mt-6">주제를 분석하고 있습니다...</h2>
                <p class="text-slate-600 mt-2">최적의 토론을 위해 AI가 3단계에 걸쳐 준비합니다.</p>
            </div>
            <div class="relative w-full max-w-2xl mx-auto p-4">
                <div class="absolute top-1/2 left-0 w-full h-1 bg-slate-200 -translate-y-1/2"></div>
                <div id="progress-bar" class="absolute top-1/2 left-0 h-1 bg-blue-500 -translate-y-1/2 transition-all duration-1000" style="width: 15%;"></div>
                <div class="relative flex justify-between items-start">
                    <div id="step-1" class="text-center z-10">
                        <div class="w-12 h-12 rounded-full bg-blue-500 text-white flex items-center justify-center mx-auto font-bold text-xl ring-4 ring-white">1</div>
                        <p class="text-sm font-bold mt-3">주제 분석</p>
                        <p id="step-1-status" class="text-xs text-slate-500">쟁점 도출 중</p>
                    </div>
                    <div id="step-2" class="text-center z-10 opacity-50">
                        <div class="w-12 h-12 rounded-full bg-white border-2 border-slate-300 flex items-center justify-center mx-auto font-bold text-xl text-slate-400 ring-4 ring-white">2</div>
                        <p class="text-sm font-bold mt-3 text-slate-400">자료 수집</p>
                        <p id="step-2-status" class="text-xs text-slate-500">대기 중</p>
                    </div>
                    <div id="step-3" class="text-center z-10 opacity-50">
                        <div class="w-12 h-12 rounded-full bg-white border-2 border-slate-300 flex items-center justify-center mx-auto font-bold text-xl text-slate-400 ring-4 ring-white">3</div>
                        <p class="text-sm font-bold mt-3 text-slate-400">패널 선정</p>
                        <p id="step-3-status" class="text-xs text-slate-500">대기 중</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-jury" class="screen screen-card">
        <div class="screen-header"><span>배심원단 구성 완료</span></div>
        <div id="jury-container" class="screen-body">
            </div>
    </div>

    <div id="screen-5" class="screen screen-card" style="max-width: 80rem;">
        <div class="screen-header">
            <span>실시간 토론</span>
            <button id="view-evidence-btn" class="btn btn-subtle text-sm py-2 px-4">📂 핵심 자료집 보기</button>
        </div>

        <div id="evidence-modal" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0 z-50">
            <div class="screen-card w-full max-w-2xl max-h-[80vh] flex flex-col">
                <div class="screen-header">
                    <span>📂 핵심 자료집</span>
                    <button class="text-2xl font-bold" onclick="toggleModal('evidence-modal')">&times;</button>
                </div>
                <div id="evidence-modal-body" class="screen-body overflow-y-auto">
                    <p>데이터를 불러오는 중입니다...</p>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 p-6 bg-slate-50">
            <div class="lg:col-span-2 h-[70vh] flex flex-col">
                <div id="chatbox" class="flex-1 overflow-y-auto space-y-6 p-4 border rounded-lg bg-white shadow-inner">
                    <div class="text-center text-slate-500">AI 에이전트들의 발언을 기다리고 있습니다...</div>
                </div>
                <div id="user-action-panel" class="pt-4"></div>
            </div>

            <div class="space-y-6">
                <div id="critical-hit-panel" class="bg-white border p-4 rounded-xl">
                    <h3 class="font-bold text-slate-700 text-lg mb-2">⚡ 결정적 발언</h3>
                    <p class="text-sm text-slate-700">진행 중...</p>
                </div>
                <div class="bg-white border p-4 rounded-xl">
                    <h3 class="font-bold text-slate-700 text-lg mb-4">🔄 토론 흐름도</h3>
                    <div id="flow-diagram-container" class="relative">
                        <p class="text-sm text-slate-700">진행 중...</p>
                    </div>
                </div>
                <div class="bg-white border p-4 rounded-xl">
                    <h3 class="font-bold text-slate-700 text-lg mb-4">📊 에이전트 입장 변화</h3>
                    <div id="stance-tracker" class="space-y-3">
                        <p class="text-sm text-slate-700">진행 중...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-6" class="screen screen-card">
        <div class="screen-header"><span>최종 분석 보고서</span></div>
        <div class="screen-body">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-8">
                <h2 class="text-3xl font-bold text-slate-800">최종 분석 보고서</h2>
                <button class="btn btn-secondary w-full sm:w-auto">📥 PDF 다운로드</button>
            </div>
            <div class="text-center p-8 border rounded-lg">
                <h3 class="text-xl font-bold">보고서 생성 중...</h3>
                <p class="text-slate-600 mt-2">토론이 종료되었으며, 최종 보고서가 백그라운드에서 생성되고 있습니다. 완료되면 이 화면이 자동으로 업데이트됩니다.</p>
            </div>
        </div>
    </div>
    
    <script>
        let evidenceDataCache = null; // 핵심 자료집 데이터를 캐싱할 변수

        // --- DOM Elements ---
        const loginScreen = document.getElementById('screen-login');
        const topicScreen = document.getElementById('screen-topic');
        const analysisScreen = document.getElementById('screen-analysis'); // 분석 화면 요소
        const juryScreen = document.getElementById('screen-jury');       // 배심원단 화면 요소
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const loginError = document.getElementById('login-error');
        const userEmailDisplay = document.getElementById('user-email-display');
        const topicInput = document.getElementById('topic-input');
        const fileInput = document.getElementById('file-input');
        const fileNameDisplay = document.getElementById('file-name-display');
        const startAnalysisButton = document.getElementById('start-analysis-button');
        const juryContainer = document.getElementById('jury-container');

        // --- Global Variables ---
        let currentDiscussionId = null;     // 현재 토론 ID를 저장할 전역 변수
        let isPollingActive = false;        // 폴링 루프의 활성 상태를 관리
        let displayedMessagesCount = 0;     // 화면에 표시된 메시지 수 (전체)
        let regularMessageCount = 0;        // 일반 에이전트 메시지 카운터 (좌/우 정렬용)
        let isRendering = false;
        
        // --- Functions ---
        
        /**
         * 화면을 전환하는 함수
         * @param {string} screenId - 표시할 화면의 ID
         */
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        /**
         * 로그인 API를 호출하는 함수
         */
        async function handleLogin() {
            const email = emailInput.value;
            const password = passwordInput.value;

            // 입력값 검증
            if (!email || !password) {
                loginError.textContent = '이메일과 비밀번호를 모두 입력해주세요.';
                return;
            }

            // 로딩 상태 표시
            loginButton.disabled = true;
            loginButton.textContent = '로그인 중...';
            loginError.textContent = '';

            // API는 x-www-form-urlencoded 형식을 요구하므로 FormData를 사용
            const formData = new URLSearchParams();
            formData.append('username', email);
            formData.append('password', password);

            try {
                const response = await fetch(`/api/v1/login/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData,
                });

                if (response.ok) {
                    const data = await response.json();
                    // JWT 토큰을 localStorage에 저장
                    localStorage.setItem('accessToken', data.access_token);
                    localStorage.setItem('userEmail', email);

                    // 로그인 성공 후 UI 업데이트 및 화면 전환
                    console.log('로그인 성공:', data);
                    updateUIForLoggedInState();
                    showScreen('screen-topic');

                } else {
                    const errorData = await response.json();
                    loginError.textContent = errorData.detail || '로그인에 실패했습니다. 이메일 또는 비밀번호를 확인하세요.';
                    console.error('로그인 실패:', errorData);
                }
            } catch (error) {
                loginError.textContent = '서버에 연결할 수 없습니다. 잠시 후 다시 시도해주세요.';
                console.error('네트워크 오류:', error);
            } finally {
                // 로딩 상태 해제
                loginButton.disabled = false;
                loginButton.textContent = '로그인';
            }
        }

        /**
         * 로그아웃 처리 함수
         */
        function handleLogout() {
            // 저장된 토큰과 이메일 정보 삭제
            localStorage.removeItem('accessToken');
            localStorage.removeItem('userEmail');
            
            console.log('로그아웃 되었습니다.');
            
            // UI 업데이트 및 로그인 화면으로 전환
            updateUIForLoggedOutState();
            showScreen('screen-login');
        }

        /**
         * '분석 시작' 버튼 클릭 시 오케스트레이션 파이프라인을 실행하는 함수
         */
        async function handleOrchestration() {
            const topic = topicInput.value.trim();
            const file = fileInput.files[0];
            const token = localStorage.getItem('accessToken');

            if (!topic) {
                alert('토론할 주제를 입력해주세요.');
                return;
            }
            if (!token) {
                alert('로그인이 필요합니다.');
                showScreen('screen-login');
                return;
            }

            showScreen('screen-analysis');
            //runAnalysisAnimation();
            updateAnalysisStep(1, '주제 분석 중...'); // 1단계 시작

            const formData = new FormData();
            formData.append('topic', topic);
            if (file) {
                formData.append('file', file);
            }

            try {
                // 2. API 호출 시작
                updateAnalysisStep(2, '자료 수집 중...'); // 2단계 시작
                const response = await fetch('/api/v1/discussions/', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData,
                });

                if (response.status === 201) {
                    // 3. API 응답 성공 시 '3단계' 애니메이션 시작
                    updateAnalysisStep(3, '패널 선정 중...'); // 3단계 시작
                    const debateTeam = await response.json();
                    console.log('Orchestration 성공:', debateTeam);
                    
                    currentDiscussionId = debateTeam.discussion_id;
                    console.log('저장된 Discussion ID:', currentDiscussionId);

                    // 4. 잠시 후 최종 화면으로 전환
                    setTimeout(() => {
                        renderJuryScreen(debateTeam);
                        showScreen('screen-jury');
                    }, 1000); // 1초 후 전환

                } else {
                    const errorData = await response.json();
                    alert(`분석 중 오류가 발생했습니다: ${errorData.detail}`);
                    showScreen('screen-topic');
                }
            } catch (error) {
                alert('서버에 연결할 수 없습니다.');
                showScreen('screen-topic');
                console.error('Orchestration 네트워크 오류:', error);
            }
        }

        // 분석 단계별 UI 업데이트를 위한 헬퍼 함수
        function updateAnalysisStep(stepNumber, statusText) {
            const progressBar = document.getElementById('progress-bar');
            const analysisStatusText = document.getElementById('analysis-status-text');
            
            analysisStatusText.textContent = statusText;

            if (stepNumber === 1) {
                progressBar.style.width = '15%';
            } else if (stepNumber === 2) {
                progressBar.style.width = '50%';
                const step2Div = document.getElementById('step-2');
                step2Div.classList.remove('opacity-50');
                step2Div.querySelector('div').className = 'w-12 h-12 rounded-full bg-blue-500 text-white flex items-center justify-center mx-auto font-bold text-xl ring-4 ring-white';
                document.getElementById('step-1-status').textContent = '완료';
                document.getElementById('step-2-status').textContent = '진행 중';
            } else if (stepNumber === 3) {
                progressBar.style.width = '100%';
                const step3Div = document.getElementById('step-3');
                step3Div.classList.remove('opacity-50');
                step3Div.querySelector('div').className = 'w-12 h-12 rounded-full bg-blue-500 text-white flex items-center justify-center mx-auto font-bold text-xl ring-4 ring-white';
                document.getElementById('step-2-status').textContent = '완료';
                document.getElementById('step-3-status').textContent = '진행 중';
            }
        }

        /**
         * 분석 과정 3단계 애니메이션을 시뮬레이션하는 함수
         */
        /*
        function runAnalysisAnimation() {
            // UI 요소 가져오기
            const progressBar = document.getElementById('progress-bar');
            const analysisStatusText = document.getElementById('analysis-status-text');
            const steps = {
                1: { div: document.getElementById('step-1'), status: document.getElementById('step-1-status') },
                2: { div: document.getElementById('step-2'), status: document.getElementById('step-2-status') },
                3: { div: document.getElementById('step-3'), status: document.getElementById('step-3-status') }
            };

            // 2단계 진행
            setTimeout(() => {
                progressBar.style.width = '50%';
                analysisStatusText.textContent = '웹 검색 및 파일 분석 중...';
                steps[1].status.textContent = '완료';
                steps[2].div.classList.remove('opacity-50');
                steps[2].div.querySelector('div').className = 'w-12 h-12 rounded-full bg-blue-500 text-white flex items-center justify-center mx-auto font-bold text-xl ring-4 ring-white';
                steps[2].status.textContent = '자료 확보 중';
            }, 1500); // 1.5초 후

            // 3단계 진행
            setTimeout(() => {
                progressBar.style.width = '100%';
                analysisStatusText.textContent = '최적의 전문가 팀 구성 중...';
                steps[2].status.textContent = '완료';
                steps[3].div.classList.remove('opacity-50');
                steps[3].div.querySelector('div').className = 'w-12 h-12 rounded-full bg-blue-500 text-white flex items-center justify-center mx-auto font-bold text-xl ring-4 ring-white';
                steps[3].status.textContent = '선발 중';
            }, 3000); // 3초 후
        }
        */

        /**
         * API 응답을 받은 후 애니메이션을 완료하고 화면을 전환하는 함수
         * @param {object} debateTeam - API 응답 데이터
         */
        /*
        function finishAnalysisAnimation(debateTeam) {
             setTimeout(() => {
                renderJuryScreen(debateTeam);
                showScreen('screen-jury');
            }, 1000); // 마지막 단계 보여주고 1초 후 전환
        }
        */

        /**
         * API 응답 데이터를 기반으로 배심원단 확인 화면을 동적으로 생성하는 함수
         * @param {object} teamData - /orchestrate API의 응답 데이터 (DebateTeam)
         */
        function renderJuryScreen(teamData) {
            const iconMap = { 
                "사회자": "🧑", "거시경제 전문가": "🌍", "산업 분석가": "🏭", 
                "재무 분석가": "💹", "SNS 트렌드 분석가": "📱", "비판적 관점": "🤔", 
                "워렌 버핏": "👴", "피터 린치": "👨‍💼", "스티브 잡스": "📱", 
                "일론 머스크": "🚀", "심리학 전문가": "🧠", "미래학자": "🔭", "IT 전문가": "💻" 
            };
            
            let juryHtml = '';
            teamData.jury.forEach(agent => {
                // agent.icon을 우선적으로 사용하고, 없으면 iconMap을 참조하는 로직으로 변경
                const icon = agent.icon || iconMap[agent.name] || '🤖';
                juryHtml += `
                    <div class="flex flex-col items-center text-center p-3 bg-white rounded-lg shadow-sm">
                        <span class="text-3xl">${icon}</span>
                        <p class="font-bold mt-2">${agent.name}</p>
                        <p class="text-xs text-slate-500 mt-1">${agent.model}</p>
                    </div>`;
            });

            const judgeIcon = teamData.judge.icon || iconMap[teamData.judge.name] || '🧑';
            const judgeName = teamData.judge.name;

            const fullHtml = `
                <div class="text-center mb-8">
                    <h2 class="text-2xl font-bold text-slate-800">전문가 에이전트 구성이 완료되었습니다.</h2>
                    <p class="text-slate-600 mt-2">'사회자'의 진행에 따라, 선발된 'AI 전문가'들의 심층 토론을 시작합니다.</p>
                </div>
                <div class="mb-8">
                    <div class="bg-amber-50 border-2 border-amber-400 p-4 rounded-xl flex flex-col sm:flex-row items-center gap-4">
                        <span class="text-5xl">${teamData.judge.icon || iconMap[teamData.judge.name] || '🧑'}</span>
                        <div class="text-center sm:text-left">
                            <h3 class="text-lg font-bold text-amber-800">사회자</h3>
                            <p class="text-slate-600 mt-1">${teamData.judge.model}</p>
                        </div>
                    </div>
                </div>
                <div class="border-2 border-slate-200 bg-slate-50 p-6 rounded-xl">
                    <h3 class="font-bold text-slate-700 text-center mb-4 text-lg">AI 전문가 에이전트</h3>
                    <p class="text-center text-sm text-slate-500 mb-4">${teamData.reason}</p>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">${juryHtml}</div>
                </div>
                <button id="start-debate-btn" class="btn btn-primary w-full mt-8">이 구성으로 토론 시작하기</button>
            `;
            juryContainer.innerHTML = fullHtml;
            
            // '토론 시작하기' 버튼에 이벤트 리스너 
            document.getElementById('start-debate-btn').addEventListener('click', startDebate);
        }

        /**
         * 모달창을 토글하는 헬퍼 함수
         */
        function toggleModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                setTimeout(() => modal.classList.remove('opacity-0'), 10);
            } else {
                modal.classList.add('opacity-0');
                setTimeout(() => modal.classList.add('hidden'), 300);
            }
        }

        /**
         * '핵심 자료집 보기' 버튼 클릭 시 실행되는 함수
         */
        async function showEvidenceModal() {
            // 이미 데이터를 불러왔으면 캐시된 데이터로 모달을 즉시 표시
            if (evidenceDataCache) {
                renderEvidenceModal(evidenceDataCache);
                toggleModal('evidence-modal');
                return;
            }

            // 데이터를 처음 불러오는 경우
            if (!currentDiscussionId) {
                alert("오류: 현재 토론 ID를 찾을 수 없습니다.");
                return;
            }
            const token = localStorage.getItem('accessToken');
            
            try {
                const response = await fetch(`/api/v1/discussions/${currentDiscussionId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch discussion details.');
                
                const discussionData = await response.json();
                evidenceDataCache = discussionData.evidence_briefing; // 결과 캐싱
                
                renderEvidenceModal(evidenceDataCache);
                toggleModal('evidence-modal');

            } catch (error) {
                console.error("Error fetching evidence data:", error);
                document.getElementById('evidence-modal-body').innerHTML = '<p>데이터를 불러오는 데 실패했습니다.</p>';
                toggleModal('evidence-modal');
            }
        }

        /**
         * 받아온 데이터로 모달 내용을 채우는 함수
         */
        function renderEvidenceModal(data) {
            const container = document.getElementById('evidence-modal-body');
            if (!data) {
                container.innerHTML = '<p>핵심 자료집 데이터가 없습니다.</p>';
                return;
            }

            // URL 유효성 검사 및 <a> 태그 생성 헬퍼 함수
            function formatSource(source) {
                // 간단한 URL 형식 검사 (http/https로 시작하는지)
                if (source.startsWith('http://') || source.startsWith('https://')) {
                    return `<a href="${source}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline break-word-container">${source}</a>`;
                }
                return `<span class="break-word-container">${source}</span>`;
            }

            const webHtml = data.web_evidence && data.web_evidence.length > 0
                ? data.web_evidence.map(item => `
                    <div class="mb-3 p-3 border border-gray-200 rounded-md bg-white shadow-sm">
                        <p class="font-semibold text-gray-700 mb-1">출처: ${formatSource(item.source)}</p>
                        <p class="text-gray-800">${item.summary}</p>
                        <p class="text-sm text-gray-500 mt-1">발행일: ${item.publication_date || '알 수 없음'}</p>
                    </div>
                `).join('')
                : '<p class="text-gray-600">관련 웹 검색 결과가 없습니다.</p>';

            const fileHtml = data.file_evidence && data.file_evidence.length > 0
                ? data.file_evidence.map(item => `
                    <div class="mb-3 p-3 border border-gray-200 rounded-md bg-white shadow-sm">
                        <p class="font-semibold text-gray-700 mb-1">첨부 파일: <span class="break-word-container">${item.source}</span></p>
                        <p class="text-gray-800">${item.summary}</p>
                        <p class="text-sm text-gray-500 mt-1">확인일: ${item.publication_date || '알 수 없음'}</p>
                    </div>
                `).join('')
                : '<p class="text-gray-600">첨부된 파일이 없습니다.</p>';

            container.innerHTML = `
                <div class="mb-6">
                    <h3 class="font-bold text-lg mb-3 text-primary-dark">🌐 웹 검색 결과 요약</h3>
                    <div class="bg-gray-50 p-4 rounded-lg shadow-inner space-y-4">${webHtml}</div>
                </div>
                <div>
                    <h3 class="font-bold text-lg mb-3 text-primary-dark">📁 사용자 첨부 파일 요약</h3>
                    <div class="bg-gray-50 p-4 rounded-lg shadow-inner space-y-4">${fileHtml}</div>
                </div>
            `;
        }

        /**
         * '토론 시작하기' 버튼 클릭 시, 백엔드에 토론 실행을 요청하는 함수
         */
        async function startDebate() {

            if (!currentDiscussionId) {
                alert('오류: 토론 ID를 찾을 수 없습니다.');
                return;
            }

            const token = localStorage.getItem('accessToken');
            const startDebateBtn = document.getElementById('start-debate-btn');

            // 로딩 상태 표시
            startDebateBtn.disabled = true;
            startDebateBtn.textContent = '토론을 준비 중입니다...';

            try {
                const response = await fetch(`/api/v1/discussions/${currentDiscussionId}/turns`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ user_vote: null }) // 첫 시작이므로 투표 값은 null
                });

                if (response.status === 202) { // 202 Accepted
                    console.log('백그라운드 토론 작업이 성공적으로 시작되었습니다.');
                    displayedMessagesCount = 0; // 새 토론 시작 시 카운트 초기화
                    regularMessageCount = 0;    // 일반 메시지 카운트 초기화
                    const chatbox = document.getElementById('chatbox');
                    chatbox.innerHTML = '<div id="waiting-message" class="text-center text-slate-500">AI 에이전트들의 발언을 기다리고 있습니다...</div>'; // 초기 메시지 설정
                    // 다음 단계: 실시간 토론 화면으로 전환
                    showScreen('screen-5'); 

                    // 채팅창을 비우는 대신, 범용 "입력 중" 인디케이터를 표시합니다.
                    showGeneralTypingIndicator(true); 

                    startPolling(currentDiscussionId); // 폴링 시작

                    // '핵심 자료집 보기' 버튼에 이벤트 리스너 연결
                    const evidenceBtn = document.getElementById('view-evidence-btn');
                    evidenceBtn.addEventListener('click', showEvidenceModal);
                } else {
                    const errorData = await response.json();
                    alert(`토론 시작에 실패했습니다: ${errorData.detail}`);
                    startDebateBtn.disabled = false;
                    startDebateBtn.textContent = '이 구성으로 토론 시작하기';
                }
            } catch (error) {
                alert('서버 연결에 실패했습니다.');
                console.error('토론 시작 API 호출 오류:', error);
                startDebateBtn.disabled = false;
                startDebateBtn.textContent = '이 구성으로 토론 시작하기';
            }
        }

        /**
         * 주기적으로 토론 상태를 서버에 요청하는 폴링을 시작하는 함수
         */
        function startPolling(discussionId) {
            if (isPollingActive) {
                return; // 이미 폴링이 진행 중이면 중복 실행 방지
            }
            isPollingActive = true;
            console.log(`Polling started for ${discussionId}`);
            pollDiscussionStatus(discussionId); // 즉시 첫 번째 폴링 시작
        }

        /**
         * 서버에 토론 상태를 GET으로 요청하는 함수
         */
        async function pollDiscussionStatus(discussionId) {
            if (!isPollingActive) {
                console.log("Polling was stopped externally.");
                return;
            }

            const token = localStorage.getItem('accessToken');
            try {
                const response = await fetch(`/api/v1/discussions/${discussionId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (response.ok) {
                    const discussionData = await response.json();
                    
                    // 새 메시지가 있으면 화면에 추가 (기존 로직)
                    await updateTranscript(discussionData.transcript, discussionData.participants);

                    // --- [핵심 수정] 상태에 따른 분기 처리 ---
                    if (discussionData.status === 'waiting_for_vote') {
                        console.log('%c[Polling] Status is "waiting_for_vote". Stopping poll for user action.', 'color: green; font-weight: bold;');
                        isPollingActive = false; // 사용자 액션 대기, 폴링 중지
                        renderUxPanels(discussionData); 
                        renderUserActionPanel(discussionData); 
                    } else if (discussionData.status === 'report_generating') {
                        // 보고서 생성 중, 계속 폴링
                        console.log(`[Polling] Status is "report_generating". Continuing poll in 3 seconds.`);
                        setTimeout(() => pollDiscussionStatus(discussionId), 3000);
                    } else if (discussionData.status === 'completed') {
                        // 보고서 생성 완료, 폴링 중지 및 보고서 표시
                        console.log(`%c[Polling] Report generation is "completed". Stopping poll and displaying report.`, 'color: blue; font-weight: bold;');
                        isPollingActive = false;
                        // [1-3 단계에서 구현 예정]
                        // displayReport(discussionData.report_html, discussionData.pdf_url); 
                        
                        // 현재 단계에서는 임시 메시지를 표시합니다.
                        document.getElementById('user-action-panel').innerHTML = `
                            <div class="text-center p-8 border rounded-lg bg-green-50 border-green-400">
                                <h3 class="text-xl font-bold text-green-800">✅ 보고서 생성 완료</h3>
                                <p class="text-slate-600 mt-2">다음 단계에서 이곳에 보고서가 표시됩니다.</p>
                            </div>
                        `;
                    } else if (discussionData.status === 'failed') {
                        console.log(`%c[Polling] Status is "failed". Stopping poll.`, 'color: red; font-weight: bold;');
                        isPollingActive = false;
                        document.getElementById('user-action-panel').innerHTML = `
                            <div class="text-center p-8 border rounded-lg bg-red-50 border-red-400">
                                <h3 class="text-xl font-bold text-red-800">❌ 보고서 생성 실패</h3>
                                <p class="text-slate-600 mt-2">오류가 발생했습니다. 관리자에게 문의하세요.</p>
                            </div>
                        `;
                    } else { // turn_inprogress 등 다른 상태
                        console.log(`[Polling] Status is "${discussionData.status}". Continuing poll in 3 seconds.`);
                        setTimeout(() => pollDiscussionStatus(discussionId), 3000);
                    }
                } else {
                    console.error('Polling failed with status:', response.status);
                    isPollingActive = false;
                }
            } catch (error) {
                console.error('Polling network error:', error);
                isPollingActive = false;
            }
        }

        /**
         * 모든 UX 패널의 렌더링을 관리하는 함수
         */
        function renderUxPanels(data) {
            if (data.round_summary) {
                renderCriticalUtterance(data.round_summary.critical_utterance);
                renderStanceChanges(data.round_summary.stance_changes, data.participants);
            }
            if (data.flow_data) {
                renderFlowDiagram(data.flow_data.interactions, data.participants);
            }
        }

        /**
         * '결정적 발언' 패널을 렌더링하는 함수
         */
        function renderCriticalUtterance(utterance) {
            const panel = document.getElementById('critical-hit-panel'); // UI에 해당 ID가 있어야 함
            if (!panel || !utterance) return;
            panel.innerHTML = `
                <h3 class="font-bold text-yellow-800 text-lg mb-2">⚡ 결정적 발언</h3>
                <div class="text-sm text-slate-700">
                    <p class="font-semibold">[${utterance.agent_name}]</p>
                    <p class="mt-1">"${utterance.message}"</p>
                </div>`;
        }

        /**
         * '에이전트 입장 변화' 패널을 렌더링하는 함수
         */
        function renderStanceChanges(stanceChanges, participants) {
            const panel = document.getElementById('stance-tracker');
            if (!panel) return;

            // [수정] stanceChanges 데이터가 없거나 비어있을 경우 초기 메시지 표시
            if (!stanceChanges || stanceChanges.length === 0) {
                panel.innerHTML = '<p class="text-sm text-slate-500 text-center">다음 라운드부터 입장 변화가 표시됩니다.</p>';
                return;
            }

            const participantMap = getParticipantMap(participants);
            let html = '';
            stanceChanges.forEach(change => {
                html += `
                    <div class="flex items-center justify-between text-sm">
                        <div class="flex items-center gap-2">
                            <span class="text-xl">${participantMap[change.agent_name]?.icon || '🤖'}</span>
                            <span class="font-semibold">${change.agent_name}</span>
                        </div>
                        <div class="font-bold flex items-center gap-1.5">
                        ${change.icon} ${change.change}
                        </div>
                    </div>`;
            });
            panel.innerHTML = html;
        }

        /**
         * 상호작용을 단순한 목록 형태로 렌더링하는 함수
         */
        function renderInteractionList(interactions, participants) {
            const container = document.getElementById('flow-diagram-container');
            
            // 로그는 유지하여 데이터 수신 여부 계속 확인
            console.log('%c[Flow Diagram] 1. Rendering list view.', 'color: blue; font-weight: bold;', {
                'Received Interactions': interactions
            });

            if (!container) {
                console.error('[Flow Diagram] Error: Container element not found!');
                return;
            }

            // 상호작용 데이터가 없는 경우 메시지 표시
            if (!interactions || interactions.length === 0) {
                container.innerHTML = '<p class="text-sm text-center text-slate-500">이번 라운드에서는 에이전트 간의 직접적인 상호작용이 감지되지 않았습니다.</p>';
                container.style.height = 'auto';
                return;
            }

            const participantMap = getParticipantMap(participants);
            container.style.height = 'auto'; // 컨테이너 높이를 내용에 맞게 자동 조절

            // 각 상호작용에 대한 HTML 행(row)을 생성
            const interactionRowsHtml = interactions.map(flow => {
                const fromAgent = participantMap[flow.from] || { icon: '🤖' };
                const toAgent = participantMap[flow.to] || { icon: '🤖' };
                
                // 상호작용 유형(agreement/disagreement)에 따라 화살표 색상 결정
                const arrowClass = flow.type === 'agreement' ? 'arrow-agreement' : 'arrow-disagreement';

                return `
                    <div class="flow-list-item">
                        <div class="flow-agent-box from">
                            <div class="w-8 h-8 rounded-full bg-slate-100 flex items-center justify-center text-xl flex-shrink-0">${fromAgent.icon}</div>
                            <span class="text-xs font-bold truncate">${flow.from}</span>
                        </div>

                        <div class="flow-arrow">
                            <svg class="${arrowClass}" viewBox="0 0 100 16" preserveAspectRatio="none"><path d="M0,8 L100,8 M90,2 L100,8 L90,14" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
                        </div>

                        <div class="flow-agent-box to">
                            <span class="text-xs font-bold truncate">${flow.to}</span>
                            <div class="w-8 h-8 rounded-full bg-slate-100 flex items-center justify-center text-xl flex-shrink-0">${toAgent.icon}</div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `<div class="w-full">${interactionRowsHtml}</div>`;
        }

        /**
         * '토론 흐름도' 패널을 렌더링하는 함수
         */
        function renderFlowDiagram(interactions, participants) {
            renderInteractionList(interactions, participants);
        }

        /**
         * 토론 흐름도 화살표를 그리는 헬퍼 함수
         */
        /**
         * 두 HTML 요소(el1, el2)를 연결하는 화살표 선(div)을 생성하여 반환합니다.
         * @param {HTMLElement} el1 - 시작 요소
         * @param {HTMLElement} el2 - 도착 요소
         * @returns {HTMLElement} - 스타일이 적용된 화살표 선 div 요소
         */
        /**
         * 두 HTML 요소를 연결하는 화살표 선을 생성하는 안정화된 함수
         * getBoundingClientRect() 대신 offsetLeft/Top을 사용하여 위치 계산의 정확성을 높입니다.
         */
        function createFlowLine(el1, el2, colorClass) {
            // 1. 각 에이전트 노드(el1, el2) 내부의 아이콘 div를 직접 참조합니다.
            const icon1 = el1.querySelector('div:first-child');
            const icon2 = el2.querySelector('div:first-child');

            // 2. offset 속성을 사용하여 부모 컨테이너 내에서의 상대적 위치를 계산합니다.
            // el.offsetLeft: 부모로부터의 가로 이격 거리
            // icon.offsetWidth: 아이콘 자체의 너비
            const x1 = el1.offsetLeft + icon1.offsetWidth / 2;
            const y1 = el1.offsetTop + icon1.offsetHeight / 2;
            const x2 = el2.offsetLeft + icon2.offsetWidth / 2;
            const y2 = el2.offsetTop + icon2.offsetHeight / 2;

            // 3. 두 점 사이의 거리(화살표 길이)와 각도 계산
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            // 4. 계산된 값을 바탕으로 화살표 DOM 요소를 생성
            const line = document.createElement('div');
            line.className = `flow-line ${colorClass}`;
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;
            
            return line;
        }

        /**
         * 사용자 액션 패널(투표, 다음 행동 버튼)을 렌더링하는 함수
         */
        function renderUserActionPanel(discussionData) {
            const actionPanel = document.getElementById('user-action-panel');
            if (!actionPanel) {
                // [로그 추가]
                console.error("[로그 오류] 'user-action-panel' 요소를 찾을 수 없습니다.");
                return;
            }

            const voteData = discussionData.current_vote;
            
            // [로그 추가] 수신된 voteData를 자세히 검사
            console.log("[로그 추가] renderUserActionPanel 내부 voteData:", voteData);
            if (voteData) {
                console.log(`[로그 추가] voteData.topic: ${voteData.topic}`);
                console.log(`[로그 추가] voteData.options: ${JSON.stringify(voteData.options)}`);
                console.log(`[로그 추가] Array.isArray(voteData.options): ${Array.isArray(voteData.options)}`);
            }

            // [수정] 렌더링 조건 검사 강화 및 로그 추가
            if (voteData && voteData.topic && Array.isArray(voteData.options) && voteData.options.length > 0) {
                console.log('%c[로그 성공] 투표 데이터가 유효하여 투표 UI를 렌더링합니다.', 'color: green');
                let optionsHtml = '';
                voteData.options.forEach(option => {
                    const optionText = String(option);
                    optionsHtml += `<button class="btn btn-subtle vote-option" data-vote="${optionText}">${optionText}</button>`;
                });
                actionPanel.innerHTML = `
                    <div class="bg-amber-100 border-l-4 border-amber-500 p-4 rounded-r-lg shadow-lg animate-fade-in">
                        <p class="font-bold text-amber-800">사회자의 투표 제안 (Round ${discussionData.turn_number})</p>
                        <p class="mt-2 text-base text-amber-900">"${voteData.topic}"</p>
                        <div id="vote-options-container" class="flex flex-wrap gap-3 justify-center mt-4">
                            ${optionsHtml}
                        </div>
                    </div>
                    <div class="flex justify-center gap-4 mt-6">
                        <button id="next-round-btn" class="btn btn-primary">투표하고 다음 라운드 진행</button>
                        <button id="end-debate-btn" class="btn btn-secondary">이대로 토론 종료</button>
                    </div>
                `;
            } else {
                console.warn('%c[로그 경고] 투표 데이터가 유효하지 않아 기본 버튼을 렌더링합니다.', 'color: orange');
                actionPanel.innerHTML = `
                    <div class="flex justify-center gap-4 mt-6">
                        <button id="next-round-btn" class="btn btn-primary">다음 라운드 진행</button>
                        <button id="end-debate-btn" class="btn btn-secondary">이대로 토론 종료</button>
                    </div>`;
            }

            // 이벤트 리스너 연결
            document.getElementById('next-round-btn').addEventListener('click', handleNextRound);
            document.getElementById('end-debate-btn').addEventListener('click', handleEndDebate);
            
            const voteOptionsContainer = document.getElementById('vote-options-container');
            if (voteOptionsContainer) {
                voteOptionsContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('vote-option')) {
                        voteOptionsContainer.querySelectorAll('.vote-option').forEach(btn => {
                            btn.classList.remove('bg-blue-600', 'text-white');
                        });
                        event.target.classList.add('bg-blue-600', 'text-white');
                    }
                });
            }
        }

        /**
         * '다음 라운드 진행' 버튼의 로직을 처리하는 함수
         */
        async function handleNextRound() {
            const nextRoundBtn = document.getElementById('next-round-btn');
            nextRoundBtn.disabled = true;
            nextRoundBtn.textContent = '다음 라운드를 준비 중입니다...';

            const selectedOption = document.querySelector('.vote-option.bg-blue-600');
            const userVote = selectedOption ? selectedOption.dataset.vote : null;
            console.log(`다음 라운드 시작. 사용자 투표: ${userVote}`);

            const token = localStorage.getItem('accessToken');
            try {
                const response = await fetch(`/api/v1/discussions/${currentDiscussionId}/turns`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ user_vote: userVote })
                });

                if (response.status === 202) {
                    document.getElementById('user-action-panel').innerHTML = ''; // 액션 패널 비우기

                    // 다음 라운드를 위해 범용 "입력 중" 인디케이터를 다시 표시합니다.
                    showGeneralTypingIndicator(true);

                    startPolling(currentDiscussionId); // 다음 라운드를 위해 폴링 다시 시작
                } else {
                    const errorData = await response.json();
                    alert(`다음 라운드 시작에 실패했습니다: ${errorData.detail}`);
                    nextRoundBtn.disabled = false;
                    nextRoundBtn.textContent = '다음 라운드 진행';
                }
            } catch (error) {
                alert('서버 연결에 실패했습니다.');
                nextRoundBtn.disabled = false;
                nextRoundBtn.textContent = '다음 라운드 진행';
            }
        }

        /**
         * '토론 종료' 버튼의 로직을 처리하는 함수
         */
        async function handleEndDebate() {
            console.log("토론 종료 및 보고서 생성 프로세스를 시작합니다.");
            isPollingActive = false; // 진행 중인 턴 폴링은 즉시 중단

            const endDebateBtn = document.getElementById('end-debate-btn');
            if (endDebateBtn) {
                // 버튼이 포함된 전체 패널을 로딩 UI로 교체하므로, 버튼 자체를 비활성화할 필요는 없습니다.
                document.getElementById('user-action-panel').innerHTML = `
                    <div class="text-center p-8 border rounded-lg bg-slate-50 animate-fade-in">
                        <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mx-auto"></div>
                        <h3 class="text-xl font-bold mt-4">최종 보고서 생성 중...</h3>
                        <p class="text-slate-600 mt-2">AI가 전체 토론 내용을 분석하고 있습니다. 완료되면 여기에 보고서가 표시됩니다.</p>
                    </div>
                `;
            }

            if (!currentDiscussionId) {
                alert("오류: 토론 ID가 없어 보고서를 생성할 수 없습니다.");
                showScreen('screen-topic'); // 오류 발생 시 주제 입력 화면으로 복귀
                return;
            }

            const token = localStorage.getItem('accessToken');
            try {
                // 백엔드에 토론 완료 및 보고서 생성 시작을 알리는 API 호출
                const response = await fetch(`/api/v1/discussions/${currentDiscussionId}/complete`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.status === 202) { // 202 Accepted
                    console.log("서버가 보고서 생성 요청을 성공적으로 접수했습니다.");
                    // 보고서 완성을 확인하기 위한 새로운 폴링 시작
                    startPolling(currentDiscussionId); 
                } else {
                    const errorData = await response.json();
                    alert("보고서 생성 시작에 실패했습니다: " + errorData.detail);
                    // 실패 시 다시 투표/액션 패널을 보여주거나, 에러 메시지를 표시할 수 있습니다.
                    // 여기서는 간단히 이전 화면으로 돌려보냅니다.
                    showScreen('screen-topic');
                }
            } catch (error) {
                alert("서버 통신 중 오류가 발생했습니다.");
                console.error("보고서 생성 API 호출 중 네트워크 오류:", error);
            }
        }

        /**
         * 대화록 데이터를 받아와 채팅창에 렌더링하는 함수
         */
        function renderTranscript(transcript, participants) {
            const chatbox = document.getElementById('chatbox');
            if (!chatbox) return;

            // 참가자 목록에서 이름과 아이콘을 매핑
            const participantMap = {};
            if (participants) {
                participants.forEach(p => {
                    participantMap[p.name] = { icon: p.icon || '🤖' };
                });
            }

            let html = '';
            if (transcript.length === 0) {
                html = '<div class="text-center text-slate-500">AI 에이전트들의 발언을 기다리고 있습니다...</div>';
            } else {
                transcript.forEach(turn => {
                    const agentName = turn.agent_name;
                    const message = turn.message.replace(/\n/g, '<br>'); // 줄바꿈 처리
                    const icon = participantMap[agentName]?.icon || '🤖';

                    html += `
                        <div class="flex gap-3 my-4 animate-fade-in">
                            <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>
                            <div>
                                <p class="text-sm font-bold text-slate-800">${agentName}</p>
                                <div class="bg-slate-100 p-3 rounded-lg mt-1 text-base inline-block">${message}</div>
                            </div>
                        </div>
                    `;
                });
            }
            chatbox.innerHTML = html;
            chatbox.scrollTop = chatbox.scrollHeight; // 자동 스크롤
        }

        /**
         * Staff 및 시스템 메시지를 위한 통합 렌더링 함수
         */
        function appendSystemMessage(turn) {
            const chatbox = document.getElementById('chatbox');
            let contentHtml = '';
            
            if (turn.agent_name === 'SNR 전문가' || turn.agent_name === '정보 검증부') {
                const data = JSON.parse(turn.message);
                let icon = '';
                let colorClass = '';

                if (turn.agent_name === 'SNR 전문가') {
                    icon = '📈';
                    colorClass = 'text-blue-600';
                    contentHtml = `<strong>SNR Score:</strong> ${data.snr_score} - ${data.reason}`;
                } else { // 정보 검증부
                    icon = '✅';
                    colorClass = 'text-green-600';
                    if (data.status === '주의 필요') {
                        icon = '⚠️';
                        colorClass = 'text-orange-600';
                    }
                    contentHtml = `<strong>검증 상태:</strong> ${data.reason}`;
                }
                contentHtml = `<div class="flex justify-center items-center gap-2 my-2 text-xs font-semibold animate-fade-in ${colorClass}">
                                 <span>${icon}</span>
                                 <span>[${turn.agent_name}]</span>
                                 <span>${contentHtml}</span>
                               </div>`;

            } else if (turn.agent_name === '사회자' || turn.agent_name === '재판관') {
                contentHtml = `<div class="flex justify-center items-center gap-2 my-4 text-sm text-amber-800 animate-fade-in">
                                 <span class="text-xl">🧑</span>
                                 <span class="font-semibold">${turn.message}</span>
                               </div>`;
            } else if (turn.agent_name === '구분선') {
                contentHtml = `<div class="text-center my-6 font-bold text-gray-400 animate-fade-in">${turn.message}</div>`;
            }

            chatbox.insertAdjacentHTML('beforeend', contentHtml);
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        /**
         * 수신된 대화록을 기반으로 새 메시지만 순차적으로 화면에 추가하는 함수
         */
        async function updateTranscript(transcript, participants) {
            if (!transcript || transcript.length <= displayedMessagesCount || isRendering) {
                return;
            }

            isRendering = true;
            
            // 범용 인디케이터가 있다면 한 번만 제거합니다.
            showGeneralTypingIndicator(false);

            const newMessages = transcript.slice(displayedMessagesCount);
            
            for (const turn of newMessages) {
                // Staff 및 시스템 에이전트인 경우 새로운 렌더링 함수 호출
                const systemAgents = ['SNR 전문가', '정보 검증부', '사회자', '구분선'];
                if (systemAgents.includes(turn.agent_name)) {
                    appendSystemMessage(turn); // 통합된 시스템 메시지 렌더러 호출
                    displayedMessagesCount++;
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    // 1. 이 메시지를 보낼 에이전트의 "입력 중..." 인디케이터를 표시합니다.
                    const indicator = showTypingIndicator(turn, participants);
                    
                    // 2. 현실감을 위해 1.5초 ~ 2.5초 사이의 랜덤한 시간 동안 기다립니다.
                    await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000));
                    
                    // 3. 인디케이터를 제거합니다.
                    indicator.remove();

                    // 4. 실제 메시지를 타이핑 효과와 함께 추가합니다.
                    const messageContainer = appendMessage(turn, participants);
                    const contentSpan = messageContainer.querySelector('.message-content');
                    await typeMessage(contentSpan, turn.message);
                    
                    // 5. 메시지 카운트를 증가시켜 중복 표시를 방지합니다.
                    displayedMessagesCount++;
                    regularMessageCount++; // 일반 메시지 카운터만 여기서 증가
                }
            }

            isRendering = false;
        }

        /**
         * Staff 에이전트 메시지를 위한 렌더링 함수
         */
        function appendStaffMessage(turn) {
            const chatbox = document.getElementById('chatbox');
            const data = JSON.parse(turn.message);
            let contentHtml = '';
            let icon = '';
            let colorClass = '';

            if (turn.agent_name === 'SNR 전문가') {
                icon = '📈';
                colorClass = 'text-blue-600';
                contentHtml = `<strong>SNR Score:</strong> ${data.snr_score} - ${data.reason}`;
            } else { // 정보 검증부
                icon = '✅';
                colorClass = 'text-green-600';
                if (data.status === '주의 필요') {
                    icon = '⚠️';
                    colorClass = 'text-orange-600';
                }
                contentHtml = `<strong>검증 상태:</strong> ${data.reason}`;
            }

            const staffMessageHtml = `
                <div class="flex justify-center items-center gap-2 my-2 text-xs font-semibold animate-fade-in ${colorClass}">
                    <span>${icon}</span>
                    <span>[${turn.agent_name}]</span>
                    <span>${contentHtml}</span>
                </div>
            `;
            chatbox.insertAdjacentHTML('beforeend', staffMessageHtml);
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        /**
         * '입력 중...' 인디케이터를 생성하고 화면에 추가하는 함수
         */
        function showTypingIndicator(turn, participants) {
            const chatbox = document.getElementById('chatbox');
            const participantMap = getParticipantMap(participants);
            const agentName = turn.agent_name;
            const icon = participantMap[agentName]?.icon || '🤖';
            const isOdd = (regularMessageCount) % 2 !== 0; // 다음 메시지의 위치를 기준으로
            
            const indicator = document.createElement('div');
            if (isOdd) {
                indicator.className = 'flex gap-3 my-4 justify-end items-end';
                indicator.innerHTML = `
                    <div class="flex flex-col items-end">
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-blue-500 text-white p-3 rounded-lg mt-1 inline-flex items-center gap-1">
                            <span class="typing-dot animate-bounce">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.2s">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.4s">.</span>
                        </div>
                    </div>
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>`;
            } else {
                indicator.className = 'flex gap-3 my-4';
                indicator.innerHTML = `
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>
                    <div>
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-slate-100 p-3 rounded-lg mt-1 inline-flex items-center gap-1">
                            <span class="typing-dot animate-bounce">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.2s">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.4s">.</span>
                        </div>
                    </div>`;
            }
            chatbox.appendChild(indicator);
            chatbox.scrollTop = chatbox.scrollHeight;
            return indicator;
        }

        /**
         * 단일 메시지의 HTML 구조를 만들고, 타이핑 효과를 위해 content span을 비워둠
         */
        function appendMessage(turn, participants) {
            const chatbox = document.getElementById('chatbox');
            const participantMap = getParticipantMap(participants);
            const agentName = turn.agent_name;
            const icon = participantMap[agentName]?.icon || '🤖';
            const isOdd = regularMessageCount % 2 !== 0;

            const messageContainer = document.createElement('div');

            if (isOdd) {
                messageContainer.className = 'flex gap-3 my-4 justify-end items-end';
                messageContainer.innerHTML = `
                    <div class="flex flex-col items-end">
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-blue-500 text-white p-3 rounded-lg mt-1 text-base inline-block max-w-xl text-left">
                            <span class="message-content"></span>
                        </div>
                    </div>
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>`;
            } else {
                messageContainer.className = 'flex gap-3 my-4';
                messageContainer.innerHTML = `
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>
                    <div>
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-slate-100 p-3 rounded-lg mt-1 text-base inline-block max-w-xl">
                            <span class="message-content"></span>
                        </div>
                    </div>`;
            }
            chatbox.appendChild(messageContainer);
            chatbox.scrollTop = chatbox.scrollHeight;
            return messageContainer;
        }

        /**
         * 간단한 마크다운을 HTML로 변환하는 함수
         */
        function markdownToHtml(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>')       // Italic
                .replace(/^\s*\*\s(.*)/gm, '<ul><li>$1</li></ul>') // Basic lists
                .replace(/\n/g, '<br>'); // Line breaks
        }

        /**
         * 참가자 정보를 맵으로 만들어주는 헬퍼 함수
         */
        function getParticipantMap(participants) {
            const map = {};
            if (participants) {
                participants.forEach(p => {
                    map[p.name] = { icon: p.icon || '🤖' };
                });
            }
            return map;
        }

        /**
         * 텍스트에 타이핑 효과를 적용하는 함수
         */
        function typeMessage(element, text) {
            return new Promise(resolve => {
                const htmlText = markdownToHtml(text);
                let i = 0;
                
                function typing() {
                    const chatbox = document.getElementById('chatbox');
                    if (i < htmlText.length) {
                        // '<'를 만나면 '>'가 나올 때까지 한번에 추가
                        if (htmlText.charAt(i) === '<') {
                            const closingTagIndex = htmlText.indexOf('>', i);
                            if (closingTagIndex !== -1) {
                                element.innerHTML += htmlText.substring(i, closingTagIndex + 1);
                                i = closingTagIndex;
                            }
                        } else {
                            element.innerHTML += htmlText.charAt(i);
                        }
                        i++;
                        chatbox.scrollTop = chatbox.scrollHeight;
                        setTimeout(typing, 20); // 다음 글자 타이핑
                    } else {
                        resolve(); // 타이핑 완료 시 Promise를 resolve
                    }
                }
                typing();
            });
        }

        /**
         * 채팅창 하단에 범용 "입력 중..." 인디케이터를 표시하거나 숨기는 함수
         */
        function showGeneralTypingIndicator(show) {
            const chatbox = document.getElementById('chatbox');
            let indicator = document.getElementById('general-typing-indicator');

            if (show) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'general-typing-indicator';
                    indicator.className = 'flex gap-3 my-4';
                    indicator.innerHTML = `
                        <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">🤖</div>
                        <div>
                            <p class="text-sm font-bold text-slate-800">AI Panel</p>
                            <div class="bg-slate-100 p-3 rounded-lg mt-1 inline-flex items-center gap-1">
                                <span class="typing-dot animate-bounce">.</span>
                                <span class="typing-dot animate-bounce" style="animation-delay: 0.2s">.</span>
                                <span class="typing-dot animate-bounce" style="animation-delay: 0.4s">.</span>
                            </div>
                        </div>`;
                    chatbox.appendChild(indicator);
                    chatbox.scrollTop = chatbox.scrollHeight;
                }
            } else {
                if (indicator) {
                    indicator.remove();
                }
            }
        }

        /**
         * 특정 에이전트의 "입력 중..." 인디케이터를 생성하고 반환하는 함수 (수정된 버전)
         */
        function showTypingIndicator(turn, participants) {
            const chatbox = document.getElementById('chatbox');
            const participantMap = getParticipantMap(participants);
            const agentName = turn.agent_name;
            const icon = participantMap[agentName]?.icon || '🤖';
            const isOdd = (displayedMessagesCount) % 2 !== 0;

            const indicator = document.createElement('div');
            
            if (isOdd) {
                indicator.className = 'flex gap-3 my-4 justify-end items-end';
                indicator.innerHTML = `
                    <div class="flex flex-col items-end">
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-blue-500 text-white p-3 rounded-lg mt-1 inline-flex items-center gap-1">
                            <span class="typing-dot animate-bounce">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.2s">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.4s">.</span>
                        </div>
                    </div>
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>`;
            } else {
                indicator.className = 'flex gap-3 my-4';
                indicator.innerHTML = `
                    <div class="w-10 h-10 rounded-full bg-slate-200 flex-shrink-0 flex items-center justify-center text-xl">${icon}</div>
                    <div>
                        <p class="text-sm font-bold text-slate-800">${agentName}</p>
                        <div class="bg-slate-100 p-3 rounded-lg mt-1 inline-flex items-center gap-1">
                            <span class="typing-dot animate-bounce">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.2s">.</span>
                            <span class="typing-dot animate-bounce" style="animation-delay: 0.4s">.</span>
                        </div>
                    </div>`;
            }
            chatbox.appendChild(indicator);
            chatbox.scrollTop = chatbox.scrollHeight;
            return indicator;
        }

        /**
         * '토론 흐름도' 패널을 원형으로 렌더링하는 새로운 함수
         */
        function renderCircularFlowDiagram(interactions, participants) {
            const container = document.getElementById('flow-diagram-container');
            
            // --- [로그 #1: 데이터 수신 확인] ---
            // 이 로그는 백엔드에서 상호작용 데이터가 정상적으로 넘어왔는지 확인하는 첫 관문입니다.
            console.log('%c[Flow Diagram] 1. Rendering Started', 'color: blue; font-weight: bold;', {
                'Received Interactions': interactions,
                'Received Participants': participants
            });

            if (!container) {
                console.error('[Flow Diagram] Error: Container element #flow-diagram-container not found!');
                return;
            }
            // [로그 추가] interactions 데이터가 없거나 비어있는 경우, 명시적으로 로그를 남기고 함수를 종료합니다.
            if (!interactions || interactions.length === 0) {
                console.warn('[Flow Diagram] ⚠️ Warning: No interactions data to display. Arrow rendering will be skipped.');
                container.innerHTML = '<p class="text-sm text-center text-slate-500">이번 라운드에서는 에이전트 간의 직접적인 상호작용이 감지되지 않았습니다.</p>';
                container.style.height = 'auto'; // 높이 초기화
                return;
            }

            container.innerHTML = ''; // 컨테이너 초기화
            container.style.height = '250px';

            const participantMap = getParticipantMap(participants);
            const juryNames = participants
                .filter(p => p.name !== '재판관')
                .map(p => p.name);

            const agentNodes = {};
            const radius = 100;
            const centerX = container.offsetWidth / 2;
            const centerY = container.offsetHeight / 2;

            // 에이전트 아이콘을 원형으로 배치 (이 부분은 정상 동작하므로 로그 생략)
            juryNames.forEach((name, i) => {
                const angle = (i / juryNames.length) * 2 * Math.PI - (Math.PI / 2);
                const x = centerX + radius * Math.cos(angle) - 24;
                const y = centerY + radius * Math.sin(angle) - 24;

                const agentNode = document.createElement('div');
                agentNode.id = `agent-node-${name.replace(/[^a-zA-Z0-9]/g, '-')}`;
                agentNode.className = 'flex flex-col items-center text-center cursor-pointer absolute';
                agentNode.style.left = `${x}px`;
                agentNode.style.top = `${y}px`;
                agentNode.innerHTML = `
                    <div class="w-12 h-12 rounded-full bg-slate-100 flex items-center justify-center text-2xl">${participantMap[name].icon}</div>
                    <p class="text-xs font-bold mt-1 w-20 truncate">${name}</p>
                `;
                container.appendChild(agentNode);
                agentNodes[name] = agentNode;
            });

            // DOM 렌더링 후 화살표 그리기
            setTimeout(() => {
                const lines = [];
                
                // --- [로그 #2: 상호작용 루프 실행 확인] ---
                // 이 로그는 수신된 interactions 배열을 순회하며 화살표를 그리려는 시도가 시작되었음을 보여줍니다.
                console.log(`[Flow Diagram] 2. Processing ${interactions.length} interactions to draw arrows...`);

                interactions.forEach(flow => {
                    const fromId = `agent-node-${flow.from.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const toId = `agent-node-${flow.to.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const fromEl = document.getElementById(fromId);
                    const toEl = document.getElementById(toId);
                    
                    // --- [로그 #3: DOM 요소 탐색 확인] ---
                    // 화살표의 시작점과 끝점이 되는 DOM 요소를 제대로 찾았는지 확인합니다. 여기서 에러가 나면 ID 생성 규칙에 문제가 있을 수 있습니다.
                    if (fromEl && toEl) {
                        console.log(`[Flow Diagram] 3. ✅ Found nodes for: ${flow.from} -> ${flow.to}`);
                        
                        const typeClass = `flow-line-${flow.type || 'disagreement'}`;
                        const line = createFlowLine(fromEl, toEl, typeClass);
                        line.dataset.from = flow.from;
                        line.dataset.to = flow.to;
                        container.appendChild(line);
                        lines.push(line);

                        // --- [로그 #4: 화살표 생성 및 추가 확인] ---
                        // 최종적으로 생성된 화살표(line) 객체와 DOM에 추가되었음을 확인합니다.
                        console.log(`[Flow Diagram] 4. Appended arrow element to container for: ${flow.from} -> ${flow.to}`, line);

                    } else {
                        console.error(`[Flow Diagram] 3. ❌ Failed to find nodes for interaction: ${flow.from} -> ${flow.to}. Check element IDs.`, { fromId, toId });
                    }
                });

                // 마우스 오버 이벤트 리스너 추가 (이 부분은 정상 동작하므로 로그 생략)
                Object.values(agentNodes).forEach(node => {
                    const agentName = node.querySelector('p').textContent;
                    node.addEventListener('mouseover', () => {
                        lines.forEach(line => {
                            if (line.dataset.from === agentName || line.dataset.to === agentName) {
                                line.classList.add('highlighted');
                            } else {
                                line.classList.add('hidden');
                            }
                        });
                    });
                    node.addEventListener('mouseout', () => {
                        lines.forEach(line => line.classList.remove('highlighted', 'hidden'));
                    });
                });
            }, 100);
        }
        
        /**
         * 로그인 상태에 따라 UI를 업데이트하는 함수
         */
        function updateUIForLoggedInState() {
            const userEmail = localStorage.getItem('userEmail');
            if (userEmail) {
                userEmailDisplay.textContent = userEmail;
            }
        }
        
        /**
         * 로그아웃 상태에 따라 UI를 업데이트하는 함수
         */
        function updateUIForLoggedOutState() {
             userEmailDisplay.textContent = '';
             emailInput.value = 'user@example.com';
             passwordInput.value = 'userpassword';
        }

        // --- Event Listeners ---
        loginButton.addEventListener('click', handleLogin);
        logoutButton.addEventListener('click', handleLogout);
        startAnalysisButton.addEventListener('click', handleOrchestration);

        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                fileNameDisplay.textContent = fileInput.files[0].name;
                fileNameDisplay.classList.add('font-semibold', 'text-primary');
            } else {
                fileNameDisplay.textContent = '참고 파일 첨부 (TXT, PDF)';
                fileNameDisplay.classList.remove('font-semibold', 'text-primary');
            }
        });

        // --- Initial Check ---
        // 페이지 로드 시, 저장된 토큰이 있는지 확인하여 로그인 상태 유지
        document.addEventListener('DOMContentLoaded', () => {
            const token = localStorage.getItem('accessToken');
            if (token) {
                console.log('저장된 토큰으로 로그인 상태 유지');
                updateUIForLoggedInState();
                showScreen('screen-topic');
            } else {
                showScreen('screen-login');
            }
        });

    </script>
</body>
</html>
